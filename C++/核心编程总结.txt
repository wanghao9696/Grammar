内存分区：
    程序运行前：
        代码区：存放编译后的代码
        全局区：
            全局变量、静态变量、常量、字符串常量、其他常量
            const修饰的全局变量----全局常量
            const修饰的局部变量----局部常量（不在全局区）
    程序运行后：
        栈区：（编译器自动分配和释放）
            函数参数值、局部变量
        堆区：
            new开辟，程序员分配释放


引用：
    数据类型 &别名 = 原名
    给变量起别名，引用必须初始化，且初始化之后不能修改
    引用作函数参数，通过引用参数产生的效果同按地址传递一样
    引用可以作函数返回值存在，但不要返回局部变量的引用（局部变量存放在栈区，使用后自动释放）
    如果函数返回值是引用，则函数调用可以作为左值存在
    引用的本质：
        在c++内部实现是一个指针常量
        （int & ref = a;  相当于  int * const ref = &a;）
    常量引用：
        利用常量引用防止误操作修改实参（有点像按值传递）
        （const int & ref = 10;  相当于  int temp = 10; const int & ref = a;）


函数提高：
    函数重载：
        函数的返回值不可以作为重载的条件
        引用作为重载条件：
            声明：void func(int &a){}   和   void func(const int &a)
            调用：int a = 10; func(a);  和   func(10);
        函数重载碰到函数默认参数可能产生冲突


类和对象：
    三种访问权限：
        公共权限 public     成员 类内可以访问 类外可以访问
        保护权限 protected  成员 类内可以访问 类外不可以访问 （继承中，子类可以访问父类）
        私有权限 private    成员 类内可以访问 类外不可以访问 （继承中，子类不可以访问父类）
    struct和class的唯一区别就在于默认的访问权限不同（struct默认权限公共，class默认权限私有）

    构造函数：
        类名(){}
        没有返回值也不写void
        函数名称与类名相同
        构造函数可以有参数，因此可以发生重载
        函数在调用对象时会自动调用构造，且只会调用一次
        分类：
            无参构造和有参构造
            普通构造和拷贝构造
        有参构造函数的调用方式：
            括号法：Person p1(10);
            显式法：Person p2 = Person(10);
            隐式转换法：Person p3 = 10;
    析构函数：
        ～类名(){}
        没有返回值也不写void
        函数名称与类名相同，在名称前加上符号～
        析构函数不可以有参数，因此不可以发生重载
        程序在对象销毁前会自动调用析构，且只会调用一次；

