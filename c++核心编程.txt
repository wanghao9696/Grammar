########## c++面向对象 ##########

内存分区模式：
    ·代码区：
        存放函数体的二进制代码，由操作系统进行管理的
    ·全局区：
        存放全局变量和静态变量以及常量
    ·栈区：
        由编译器自动分配释放，存放函数的参数值，局部变量等
    ·堆区：
        由程序员分配和释放，若程序员不释放，程序结束时由操作系统释放
    （不同区域存放的数据，赋予不同的生命周期，使能够灵活编程）
    程序运行前：
        代码区：
            存放CPU执行的机器指令
            （代码区是“共享”的，“只读”的）
        全局区：
            全局变量和静态变量存放于此
            （全局区还包含了常量区，字符串常量和其他常量也存放在此）
            （该区域的数据在程序结束后由操作系统释放）
    程序运行后：
        栈区：
            由编译器自动分配释放，存放函数的参数值，局部变量
            （不要返回局部变量的地址，栈区开辟的数据由编译器自动释放）
        堆区：
            由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
            （c++中主要利用new关键字在堆区开辟内存）
    new操作符：
        （堆区数据利用new关键字进行开辟内存）
        语法：
            new 数据类型;
            （利用new创建的数据，会返回该数据对应的类型的指针）

引用：
    （相当于给变量起别名）
    语法：
        数据类型 &别名 = 原名
        （引用必须初始化；引用在初始化后，不可以改变）
    引用做函数参数：
        作用：
            函数传参时，可以利用引用的技术让形参修饰实参；可以简化指针修改实参
        例：
            值传递：
                void mySwap01(int a, int b){
                    int temp = a;
                    a = b;
                    b = temp;
                }
            地址传递：
                void mySwap02(int *a, int *b){
                    int temp = *a;
                    *a = *b;
                    *b = temp;
                }
            引用传递：
                void mySwap03(int &a, int &b){
                    int temp = a;
                    a = b;
                    b = temp;
                }
            (通过引用参数产生的效果和按地址传递时一样的)
    引用做函数返回值：
        （引用是可以作为函数的返回值存在的）
        （不要返回局部变量引用）
        （函数调用作为左值）
    引用的本质：
        引用的本质在c++内部实现是一个指针常量
