########## c++面向对象 ##########

内存分区模式：
    ·代码区：
        存放函数体的二进制代码，由操作系统进行管理的
    ·全局区：
        存放全局变量和静态变量以及常量
    ·栈区：
        由编译器自动分配释放，存放函数的参数值，局部变量等
    ·堆区：
        由程序员分配和释放，若程序员不释放，程序结束时由操作系统释放
    （不同区域存放的数据，赋予不同的生命周期，使能够灵活编程）
    程序运行前：
        代码区：
            存放CPU执行的机器指令
            （代码区是“共享”的，“只读”的）
        全局区：
            全局变量和静态变量存放于此
            （全局区还包含了常量区，字符串常量和其他常量也存放在此）
            （该区域的数据在程序结束后由操作系统释放）
    程序运行后：
        栈区：
            由编译器自动分配释放，存放函数的参数值，局部变量
            （不要返回局部变量的地址，栈区开辟的数据由编译器自动释放）
        堆区：
            由程序员分配释放，若程序员不释放，程序结束时由操作系统回收
            （c++中主要利用new关键字在堆区开辟内存）
    new操作符：
        （堆区数据利用new关键字进行开辟内存）
        语法：
            new 数据类型;
            （利用new创建的数据，会返回该数据对应的类型的指针）

引用：
    （相当于给变量起别名）
    语法：
        数据类型 &别名 = 原名
        （引用必须初始化；引用在初始化后，不可以改变）
    引用做函数参数：
        作用：
            函数传参时，可以利用引用的技术让形参修饰实参；可以简化指针修改实参
        例：
            值传递：
                void mySwap01(int a, int b){
                    int temp = a;
                    a = b;
                    b = temp;
                }
            地址传递：
                void mySwap02(int *a, int *b){
                    int temp = *a;
                    *a = *b;
                    *b = temp;
                }
            引用传递：
                void mySwap03(int &a, int &b){
                    int temp = a;
                    a = b;
                    b = temp;
                }
            (通过引用参数产生的效果和按地址传递时一样的)
    引用做函数返回值：
        （引用是可以作为函数的返回值存在的）
        （不要返回局部变量引用）
        （函数调用作为左值）
    引用的本质：
        引用的本质在c++内部实现是一个指针常量
    常量引用：
        （常量引用主要用来修饰形参，防止误操作）

函数进阶：
    函数默认参数：
        语法：返回值类型 函数名(参数 = 默认值){}
        （有默认值参数必须放到无默认值参数的后边）
        （如果函数声明有默认值，函数实现的时候就不能有默认参数）
    函数占位参数：
        语法：返回值类型 函数名(数据类型){}
        （用来占位，调用函数时必须填补该位置）
    函数重载：
        条件：
            1. 同一个作用域下
            2. 函数名称相同
            3. 函数参数类型不同或个数不同或顺序不同
            （函数返回值不同不可作为重载的条件）
        注意：
            1. 引用作为重载条件
            2. 函数重载碰到默认参数的情况

类和对象：
    c++面向对象的三大特性：
        封装、继承、多态
    对象：
        万物都皆为对象，对象上有其“属性”和“行为”
        例：
            人可以作为对象，属性有姓名、年龄、身高、体重，行为有走、跑、跳、吃饭、睡觉...
            车也可以作为对象，属性有轮胎、方向盘、车灯，行为有载人、放音乐、放空调...
    类：
        具有相同性质的“对象”，成为“类”，比如人属于人类，车属于车类 
    封装：
        意义：
            1. 将“属性”和“行为”作为一个整体，来表现生活中的事务
            2. 将属性和行为加以权限控制
        语法：
            class 类名{
            访问权限
                属性 / 行为;
            } 
        访问权限：
            1. public 公共权限 （类内可以访问，类外可以访问）
            2. protected 保护权限 （类内可以访问，类外不可以访问）
            3. private 私有权限 （类内可以访问，类外不可以访问）
        struct和class的区别：
            二者唯一区别在于默认访问权限不同
            struct默认权限为公共；class默认权限为私有
    对象的初始化和清理：
        （对象的初始化和清理是两个非常重要的安全问题）
        （一个对象或者变量没有初始状态，对其使用后果是未知）
        （同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题）
        （c++利用构造函数和析构函数解决这些问题，这两个函数会被编译器自动调用，完成对象初始化和清理工作）
        构造函数：
            主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
            语法：
                类名(){}
                1. 没有返回值也不写void；
                2. 函数名称与类名相同；
                3. 构造函数可以有参数，因此可以发生重载；
                4. 程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次；
        析构函数：
            主要作用在于对象销毁前系统自动调用，执行一些清理工作
            语法：
                ～类名(){}
                1. 没有返回值也不写void；
                2. 函数名称与类名相同，在名称前加上符号～；
                3. 析构函数不可以有参数，因此不可以发生重载；
                4. 程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次；
        构造函数的分类及调用：
            分类方式：
                按参数分类：有参构造，无参构造；
                按类型分类：普通构造，拷贝构造；
            三种调用方式：
                括号法
                显示法
                隐式转换法
            拷贝构造函数调用时机：
                1. 使用已经创建完毕的对象来初始化一个新对象
                2. 值传递的方式给函数参数传值
                3. 以值方式返回局部对象
            默认情况下，c++编译器至少给一个类添加3个函数：
                1. 默认构造函数（无参，函数体为空）
                2. 默认析构函数（无参，函数体为空）
                3. 默认拷贝构造函数，对属性值进行值拷贝
            构造函数调用规则：
                如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
                如果用户定义拷贝构造函数，c++不会再提供其他构造函数
        深拷贝与浅拷贝：
            浅拷贝：
                简单的赋值拷贝操作
            深拷贝：
                在堆区重新申请空间，进行拷贝操作
        初始化列表：
            （c++提供了初始化列表语法，用来初始化属性）
            语法：
                构造函数(): 属性1(值1), 属性2(值2), ... {}
                (将属性1、属性2的值初始化为值1、值2)
        类对象作为类成员：
            c++类中的成员是另一个类的对象，称为对象成员
            例：
                clsaa A{}
                class B{
                    A a;
                }
            构造与析构调用顺序：
                先调用对象成员的构造，再调用本来构造
                析构顺序与构造相反
        静态成员：
            静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员
            静态成员分类：
                静态成员变量：
                    ·所有对象共享同一份数据
                    ·在编译阶段分配内存
                    ·类内声明，类外初始化（数据类型 类名::静态成员变量 = 初始值）
                静态成员函数：
                    ·所有对象共享一个函数
                    ·静态成员函数只能访问静态成员变量
    C++对象模型和this指针：
        成员变量和成员函数分开存储：
            c++中，类内成员变量和成员函数分开存储，只由非静态成员才属于类的对象
        this指针概念：
            